#!/usr/bin/env python3
"""
Apply custom_verification logic based on metadata combinations

This script implements the exact combinations specified in the requirements:
- format_1 statements: 5 combinations
- format_2 statements: 3 combinations

Results are stored in summary.custom_verification column.

Usage:
    python scripts/analysis/apply_custom_verification.py
    python scripts/analysis/apply_custom_verification.py --dry-run
"""

import sys
import os
import argparse
import logging
from pathlib import Path
from dotenv import load_dotenv
from sqlalchemy import create_engine, text
from tqdm import tqdm

# Setup paths
load_dotenv(Path(__file__).parent.parent.parent / '.env')
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


def get_database_engine():
    """Create database engine."""
    DB_USER = os.getenv('DB_USER')
    DB_PASSWORD = os.getenv('DB_PASSWORD')
    DB_HOST = os.getenv('DB_HOST')
    DB_PORT = os.getenv('DB_PORT', '3306')
    DB_NAME = os.getenv('DB_NAME')

    return create_engine(
        f'mysql+pymysql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}',
        pool_pre_ping=True,
        pool_recycle=3600
    )


def classify_format_1(row):
    """
    Classify format_1 Airtel statements based on metadata combinations.

    Returns: (verification_level, reason)
    """
    meta_title = row['meta_title'] if row['meta_title'] else 'N/A'
    meta_author = row['meta_author'] if row['meta_author'] else 'N/A'
    meta_producer = row['meta_producer'] if row['meta_producer'] else 'N/A'
    meta_created_at = row['meta_created_at']
    meta_modified_at = row['meta_modified_at']
    balance_match = row['balance_match']
    balance_diff_change_ratio = row['balance_diff_change_ratio'] or 0

    # Combination 1: Valid PDFs generated by Airtel
    if (meta_title == 'PDF Template' and
        meta_author == 'N/A' and
        meta_producer == 'Qt 4.8.7' and
        meta_created_at is not None and
        meta_modified_at is None):
        return 'NO_ISSUES', 'Valid PDFs generated by Airtel. Some balance_match failed due to decimal values and the difference between stmt closing balance and calculated closing balance is very minimal'

    # Combination 2: Valid CSV generated by Airtel
    if (meta_title == 'Airtel Money CSV Statement' and
        meta_author == 'Airtel' and
        meta_producer == 'CSV Export' and
        meta_created_at is None and
        meta_modified_at is None):
        return 'NO_ISSUES', 'Valid CSV generated by Airtel. Some balance_match failed due to decimal values and the difference between stmt closing balance and calculated closing balance is very minimal'

    # Combination 3: Samsung Electronics - needs other metrics
    if (meta_title == 'N/A' and
        meta_author == 'N/A' and
        meta_producer == 'Samsung Electronics' and
        meta_created_at is None):
        # Check balance_diff_change_ratio
        if balance_match == 'Success' and balance_diff_change_ratio < 0.1:
            return 'NO_ISSUES', 'Need to look at other fields to determine if fraud or not. Balance match verified (valid: 68920834b593e, 68959565d170f)'
        else:
            return 'CRITICAL', f'Need to look at other fields to determine if fraud or not. Balance_diff_change_ratio is very high ({balance_diff_change_ratio:.2%}) (not valid: 68b02336021d7, 68c167ff3fc15)'

    # Combination 4: USER + Microsoft Word - FATAL
    if (meta_title == 'PDF Template' and
        meta_author == 'USER' and
        ('Microsoft' in meta_producer or 'Word' in meta_producer or 'Qt 4.8.7' in meta_producer) and
        meta_created_at is not None and
        meta_modified_at is not None):
        return 'FATAL', f'Confirm fraud if balance_diff_change_ratio is high. For some statements with low ratio (689717b8a073e, 68933d714c75a) some rows are definitely edited. Producer: {meta_producer}'

    # Combination 5: PDFium - NO_ISSUES if verified
    if (meta_title == 'N/A' and
        meta_author == 'N/A' and
        meta_producer == 'PDFium' and
        meta_created_at is None and
        meta_modified_at is None):
        if balance_match == 'Success':
            return 'NO_ISSUES', 'Status: VERIFIED, balance_match: SUCCESS'
        else:
            return 'WARNING', 'PDFium producer but balance mismatch'

    # Default: unclassified
    return None, None


def classify_format_2(row):
    """
    Classify format_2 Airtel statements based on metadata combinations.

    Returns: (verification_level, reason)
    """
    header_row_manipulation_count = row['header_row_manipulation_count'] or 0
    meta_producer = row['meta_producer'] if row['meta_producer'] else 'N/A'
    balance_match = row['balance_match']
    run_id = row['run_id']

    # Combination 1: Header manipulation (FATAL)
    # Ignore run_id 678fbedd976c7
    if header_row_manipulation_count > 0 and run_id != '678fbedd976c7':
        return 'FATAL', f'This means that header was intentionally manipulated ({header_row_manipulation_count} times)'

    # Combination 2: Microsoft Word/Excel editing (FATAL)
    if any(keyword in meta_producer for keyword in [
        'Microsoft® Word for Microsoft 365',
        'Microsoft® Excel® 2010',
        'Microsoft® Excel® 2016',
        'Microsoft® Word 2013',
        'MicrosoftÂ® Word 2013',
        'Microsoft Word',
        'Microsoft Excel'
    ]):
        return 'FATAL', f'This means the statement was edited using microsoft word and later converted to PDF. Producer: {meta_producer}'

    # Combination 3: Verified statements (NO_ISSUES)
    if balance_match == 'Success':
        return 'NO_ISSUES', 'Status: VERIFIED or VERIFIED_WITH_WARNINGS. Balance match succeeded. This means that the statement is valid'

    # Default: unclassified
    return None, None


def apply_custom_verification(engine, dry_run=False):
    """
    Apply custom_verification logic to all statements.

    Args:
        engine: SQLAlchemy engine
        dry_run: If True, don't update database

    Returns:
        Statistics dict
    """
    logger.info("Fetching statements for classification...")

    # Fetch all Airtel statements (UMTN and UATL only)
    query = text("""
        SELECT
            s.id,
            s.run_id,
            m.format,
            s.balance_match,
            s.balance_diff_change_ratio,
            s.meta_title,
            s.meta_author,
            s.meta_producer,
            s.meta_created_at,
            s.meta_modified_at,
            m.header_row_manipulation_count
        FROM summary s
        INNER JOIN metadata m ON s.run_id = m.run_id
        WHERE s.acc_prvdr_code = 'UATL'
    """)

    with engine.connect() as conn:
        result = conn.execute(query)
        rows = result.fetchall()

    logger.info(f"Processing {len(rows):,} statements...")

    # Statistics
    stats = {
        'total': len(rows),
        'format_1': 0,
        'format_2': 0,
        'classified': 0,
        'unclassified': 0,
        'no_issues': 0,
        'warning': 0,
        'critical': 0,
        'fatal': 0
    }

    updates = []

    for row in tqdm(rows, desc="Classifying statements"):
        row_dict = dict(row._mapping)
        format_type = row_dict['format']

        if format_type == 'format_1':
            stats['format_1'] += 1
            verification, reason = classify_format_1(row_dict)
        elif format_type == 'format_2':
            stats['format_2'] += 1
            verification, reason = classify_format_2(row_dict)
        else:
            verification, reason = None, None

        if verification:
            stats['classified'] += 1

            if verification == 'NO_ISSUES':
                stats['no_issues'] += 1
            elif verification == 'WARNING':
                stats['warning'] += 1
            elif verification == 'CRITICAL':
                stats['critical'] += 1
            elif verification == 'FATAL':
                stats['fatal'] += 1

            updates.append({
                'id': row_dict['id'],
                'verification': verification,
                'reason': reason
            })
        else:
            stats['unclassified'] += 1

    logger.info(f"\nClassification Summary:")
    logger.info(f"  Total: {stats['total']:,}")
    logger.info(f"  Format 1: {stats['format_1']:,}")
    logger.info(f"  Format 2: {stats['format_2']:,}")
    logger.info(f"  Classified: {stats['classified']:,} ({stats['classified']/stats['total']*100:.1f}%)")
    logger.info(f"  Unclassified: {stats['unclassified']:,} ({stats['unclassified']/stats['total']*100:.1f}%)")
    logger.info(f"\nVerification Levels:")
    logger.info(f"  NO_ISSUES: {stats['no_issues']:,} ({stats['no_issues']/stats['total']*100:.1f}%)")
    logger.info(f"  WARNING: {stats['warning']:,} ({stats['warning']/stats['total']*100:.1f}%)")
    logger.info(f"  CRITICAL: {stats['critical']:,} ({stats['critical']/stats['total']*100:.1f}%)")
    logger.info(f"  FATAL: {stats['fatal']:,} ({stats['fatal']/stats['total']*100:.1f}%)")

    if not dry_run:
        logger.info(f"\nUpdating database with {len(updates):,} classifications...")

        with engine.connect() as conn:
            for update in tqdm(updates, desc="Updating database"):
                conn.execute(
                    text("""
                        UPDATE summary
                        SET custom_verification = :verification,
                            flag_reason = :reason
                        WHERE id = :id
                    """),
                    update
                )
            conn.commit()

        logger.info("✓ Database updated successfully")
    else:
        logger.info("\n[DRY RUN] No changes made to database")

    return stats


def main():
    parser = argparse.ArgumentParser(
        description='Apply custom_verification logic based on metadata combinations',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview classifications without updating database')

    args = parser.parse_args()

    logger.info("=" * 80)
    logger.info("APPLY CUSTOM VERIFICATION LOGIC")
    logger.info("=" * 80)

    engine = get_database_engine()
    stats = apply_custom_verification(engine, dry_run=args.dry_run)

    logger.info("\n" + "=" * 80)
    logger.info("COMPLETE")
    logger.info("=" * 80)

    return 0


if __name__ == '__main__':
    exit(main())
